# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


# Copyright (c) 2019-2021, NVIDIA CORPORATION. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#  * Neither the name of NVIDIA CORPORATION nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _NvRules
else:
    import _NvRules

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _NvRules.SWIG_PyInstanceMethod_New
_swig_new_static_method = _NvRules.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_SwigPyIterator
    value = _swig_new_instance_method(_NvRules.SwigPyIterator_value)
    incr = _swig_new_instance_method(_NvRules.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_NvRules.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_NvRules.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_NvRules.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_NvRules.SwigPyIterator_copy)
    next = _swig_new_instance_method(_NvRules.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_NvRules.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_NvRules.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_NvRules.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_NvRules.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_NvRules.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_NvRules.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_NvRules.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_NvRules.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_NvRules.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _NvRules:
_NvRules.SwigPyIterator_swigregister(SwigPyIterator)

class set_string(object):
    r"""Proxy of C++ std::set< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_NvRules.set_string_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_NvRules.set_string___nonzero__)
    __bool__ = _swig_new_instance_method(_NvRules.set_string___bool__)
    __len__ = _swig_new_instance_method(_NvRules.set_string___len__)
    append = _swig_new_instance_method(_NvRules.set_string_append)
    __contains__ = _swig_new_instance_method(_NvRules.set_string___contains__)
    __getitem__ = _swig_new_instance_method(_NvRules.set_string___getitem__)
    add = _swig_new_instance_method(_NvRules.set_string_add)
    discard = _swig_new_instance_method(_NvRules.set_string_discard)

    def __init__(self, *args):
        r"""
        __init__(set_string self, std::less< std::string > const & other) -> set_string

        Parameters
        ----------
        other: std::less< std::string > const &

        __init__(set_string self) -> set_string
        __init__(set_string self, set_string other) -> set_string

        Parameters
        ----------
        other: std::set< std::string > const &

        """
        _NvRules.set_string_swiginit(self, _NvRules.new_set_string(*args))
    empty = _swig_new_instance_method(_NvRules.set_string_empty)
    size = _swig_new_instance_method(_NvRules.set_string_size)
    clear = _swig_new_instance_method(_NvRules.set_string_clear)
    swap = _swig_new_instance_method(_NvRules.set_string_swap)
    count = _swig_new_instance_method(_NvRules.set_string_count)
    begin = _swig_new_instance_method(_NvRules.set_string_begin)
    end = _swig_new_instance_method(_NvRules.set_string_end)
    rbegin = _swig_new_instance_method(_NvRules.set_string_rbegin)
    rend = _swig_new_instance_method(_NvRules.set_string_rend)
    erase = _swig_new_instance_method(_NvRules.set_string_erase)
    find = _swig_new_instance_method(_NvRules.set_string_find)
    lower_bound = _swig_new_instance_method(_NvRules.set_string_lower_bound)
    upper_bound = _swig_new_instance_method(_NvRules.set_string_upper_bound)
    equal_range = _swig_new_instance_method(_NvRules.set_string_equal_range)
    insert = _swig_new_instance_method(_NvRules.set_string_insert)
    __swig_destroy__ = _NvRules.delete_set_string

# Register set_string in _NvRules:
_NvRules.set_string_swigregister(set_string)

class set_ull(object):
    r"""Proxy of C++ std::set< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_NvRules.set_ull_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_NvRules.set_ull___nonzero__)
    __bool__ = _swig_new_instance_method(_NvRules.set_ull___bool__)
    __len__ = _swig_new_instance_method(_NvRules.set_ull___len__)
    append = _swig_new_instance_method(_NvRules.set_ull_append)
    __contains__ = _swig_new_instance_method(_NvRules.set_ull___contains__)
    __getitem__ = _swig_new_instance_method(_NvRules.set_ull___getitem__)
    add = _swig_new_instance_method(_NvRules.set_ull_add)
    discard = _swig_new_instance_method(_NvRules.set_ull_discard)

    def __init__(self, *args):
        r"""
        __init__(set_ull self, std::less< unsigned long long > const & other) -> set_ull

        Parameters
        ----------
        other: std::less< unsigned long long > const &

        __init__(set_ull self) -> set_ull
        __init__(set_ull self, set_ull other) -> set_ull

        Parameters
        ----------
        other: std::set< unsigned long long > const &

        """
        _NvRules.set_ull_swiginit(self, _NvRules.new_set_ull(*args))
    empty = _swig_new_instance_method(_NvRules.set_ull_empty)
    size = _swig_new_instance_method(_NvRules.set_ull_size)
    clear = _swig_new_instance_method(_NvRules.set_ull_clear)
    swap = _swig_new_instance_method(_NvRules.set_ull_swap)
    count = _swig_new_instance_method(_NvRules.set_ull_count)
    begin = _swig_new_instance_method(_NvRules.set_ull_begin)
    end = _swig_new_instance_method(_NvRules.set_ull_end)
    rbegin = _swig_new_instance_method(_NvRules.set_ull_rbegin)
    rend = _swig_new_instance_method(_NvRules.set_ull_rend)
    erase = _swig_new_instance_method(_NvRules.set_ull_erase)
    find = _swig_new_instance_method(_NvRules.set_ull_find)
    lower_bound = _swig_new_instance_method(_NvRules.set_ull_lower_bound)
    upper_bound = _swig_new_instance_method(_NvRules.set_ull_upper_bound)
    equal_range = _swig_new_instance_method(_NvRules.set_ull_equal_range)
    insert = _swig_new_instance_method(_NvRules.set_ull_insert)
    __swig_destroy__ = _NvRules.delete_set_ull

# Register set_ull in _NvRules:
_NvRules.set_ull_swigregister(set_ull)

class vector_string(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_NvRules.vector_string_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_NvRules.vector_string___nonzero__)
    __bool__ = _swig_new_instance_method(_NvRules.vector_string___bool__)
    __len__ = _swig_new_instance_method(_NvRules.vector_string___len__)
    __getslice__ = _swig_new_instance_method(_NvRules.vector_string___getslice__)
    __setslice__ = _swig_new_instance_method(_NvRules.vector_string___setslice__)
    __delslice__ = _swig_new_instance_method(_NvRules.vector_string___delslice__)
    __delitem__ = _swig_new_instance_method(_NvRules.vector_string___delitem__)
    __getitem__ = _swig_new_instance_method(_NvRules.vector_string___getitem__)
    __setitem__ = _swig_new_instance_method(_NvRules.vector_string___setitem__)
    pop = _swig_new_instance_method(_NvRules.vector_string_pop)
    append = _swig_new_instance_method(_NvRules.vector_string_append)
    empty = _swig_new_instance_method(_NvRules.vector_string_empty)
    size = _swig_new_instance_method(_NvRules.vector_string_size)
    swap = _swig_new_instance_method(_NvRules.vector_string_swap)
    begin = _swig_new_instance_method(_NvRules.vector_string_begin)
    end = _swig_new_instance_method(_NvRules.vector_string_end)
    rbegin = _swig_new_instance_method(_NvRules.vector_string_rbegin)
    rend = _swig_new_instance_method(_NvRules.vector_string_rend)
    clear = _swig_new_instance_method(_NvRules.vector_string_clear)
    get_allocator = _swig_new_instance_method(_NvRules.vector_string_get_allocator)
    pop_back = _swig_new_instance_method(_NvRules.vector_string_pop_back)
    erase = _swig_new_instance_method(_NvRules.vector_string_erase)

    def __init__(self, *args):
        r"""
        __init__(vector_string self) -> vector_string
        __init__(vector_string self, vector_string other) -> vector_string

        Parameters
        ----------
        other: std::vector< std::string > const &

        __init__(vector_string self, std::vector< std::string >::size_type size) -> vector_string

        Parameters
        ----------
        size: std::vector< std::string >::size_type

        __init__(vector_string self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vector_string

        Parameters
        ----------
        size: std::vector< std::string >::size_type
        value: std::vector< std::string >::value_type const &

        """
        _NvRules.vector_string_swiginit(self, _NvRules.new_vector_string(*args))
    push_back = _swig_new_instance_method(_NvRules.vector_string_push_back)
    front = _swig_new_instance_method(_NvRules.vector_string_front)
    back = _swig_new_instance_method(_NvRules.vector_string_back)
    assign = _swig_new_instance_method(_NvRules.vector_string_assign)
    resize = _swig_new_instance_method(_NvRules.vector_string_resize)
    insert = _swig_new_instance_method(_NvRules.vector_string_insert)
    reserve = _swig_new_instance_method(_NvRules.vector_string_reserve)
    capacity = _swig_new_instance_method(_NvRules.vector_string_capacity)
    __swig_destroy__ = _NvRules.delete_vector_string

# Register vector_string in _NvRules:
_NvRules.vector_string_swigregister(vector_string)

class vector_ull(object):
    r"""Proxy of C++ std::vector< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_NvRules.vector_ull_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_NvRules.vector_ull___nonzero__)
    __bool__ = _swig_new_instance_method(_NvRules.vector_ull___bool__)
    __len__ = _swig_new_instance_method(_NvRules.vector_ull___len__)
    __getslice__ = _swig_new_instance_method(_NvRules.vector_ull___getslice__)
    __setslice__ = _swig_new_instance_method(_NvRules.vector_ull___setslice__)
    __delslice__ = _swig_new_instance_method(_NvRules.vector_ull___delslice__)
    __delitem__ = _swig_new_instance_method(_NvRules.vector_ull___delitem__)
    __getitem__ = _swig_new_instance_method(_NvRules.vector_ull___getitem__)
    __setitem__ = _swig_new_instance_method(_NvRules.vector_ull___setitem__)
    pop = _swig_new_instance_method(_NvRules.vector_ull_pop)
    append = _swig_new_instance_method(_NvRules.vector_ull_append)
    empty = _swig_new_instance_method(_NvRules.vector_ull_empty)
    size = _swig_new_instance_method(_NvRules.vector_ull_size)
    swap = _swig_new_instance_method(_NvRules.vector_ull_swap)
    begin = _swig_new_instance_method(_NvRules.vector_ull_begin)
    end = _swig_new_instance_method(_NvRules.vector_ull_end)
    rbegin = _swig_new_instance_method(_NvRules.vector_ull_rbegin)
    rend = _swig_new_instance_method(_NvRules.vector_ull_rend)
    clear = _swig_new_instance_method(_NvRules.vector_ull_clear)
    get_allocator = _swig_new_instance_method(_NvRules.vector_ull_get_allocator)
    pop_back = _swig_new_instance_method(_NvRules.vector_ull_pop_back)
    erase = _swig_new_instance_method(_NvRules.vector_ull_erase)

    def __init__(self, *args):
        r"""
        __init__(vector_ull self) -> vector_ull
        __init__(vector_ull self, vector_ull other) -> vector_ull

        Parameters
        ----------
        other: std::vector< unsigned long long > const &

        __init__(vector_ull self, std::vector< unsigned long long >::size_type size) -> vector_ull

        Parameters
        ----------
        size: std::vector< unsigned long long >::size_type

        __init__(vector_ull self, std::vector< unsigned long long >::size_type size, std::vector< unsigned long long >::value_type const & value) -> vector_ull

        Parameters
        ----------
        size: std::vector< unsigned long long >::size_type
        value: std::vector< unsigned long long >::value_type const &

        """
        _NvRules.vector_ull_swiginit(self, _NvRules.new_vector_ull(*args))
    push_back = _swig_new_instance_method(_NvRules.vector_ull_push_back)
    front = _swig_new_instance_method(_NvRules.vector_ull_front)
    back = _swig_new_instance_method(_NvRules.vector_ull_back)
    assign = _swig_new_instance_method(_NvRules.vector_ull_assign)
    resize = _swig_new_instance_method(_NvRules.vector_ull_resize)
    insert = _swig_new_instance_method(_NvRules.vector_ull_insert)
    reserve = _swig_new_instance_method(_NvRules.vector_ull_reserve)
    capacity = _swig_new_instance_method(_NvRules.vector_ull_capacity)
    __swig_destroy__ = _NvRules.delete_vector_ull

# Register vector_ull in _NvRules:
_NvRules.vector_ull_swigregister(vector_ull)


def require_metrics(handle, metrics):
    ev = get_evaluator(handle)
    for metric in metrics:
        ev.require_metric(metric)

def require_rules(handle, rules):
    ev = get_evaluator(handle)
    for rule in rules:
        ev.require_rule(rule)

def metric_instances(metric):
    instances = []

    for idx in range(metric.num_instances()):
        kind = metric.kind(idx)
        if (kind == IMetric.ValueKind_FLOAT) or (kind == IMetric.ValueKind_DOUBLE):
            instances.append(metric.as_double(idx))
        elif (kind == IMetric.ValueKind_UINT64) or (kind == IMetric.ValueKind_UINT32):
            instances.append(metric.as_uint64(idx))
        else:
            instances.append(metric.as_string(idx))

    return instances

get_context = _NvRules.get_context
get_evaluator = _NvRules.get_evaluator
raise_exception = _NvRules.raise_exception
RuleKind_DEFAULT = _NvRules.RuleKind_DEFAULT

RuleKind_GUIDED = _NvRules.RuleKind_GUIDED

class IMetric(object):
    r"""Proxy of C++ NV::Rules::IMetric class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ValueKind_UNKNOWN = _NvRules.IMetric_ValueKind_UNKNOWN
    
    ValueKind_ANY = _NvRules.IMetric_ValueKind_ANY
    
    ValueKind_STRING = _NvRules.IMetric_ValueKind_STRING
    
    ValueKind_FLOAT = _NvRules.IMetric_ValueKind_FLOAT
    
    ValueKind_DOUBLE = _NvRules.IMetric_ValueKind_DOUBLE
    
    ValueKind_UINT32 = _NvRules.IMetric_ValueKind_UINT32
    
    ValueKind_UINT64 = _NvRules.IMetric_ValueKind_UINT64
    
    __swig_destroy__ = _NvRules.delete_IMetric
    name = _swig_new_instance_method(_NvRules.IMetric_name)
    kind = _swig_new_instance_method(_NvRules.IMetric_kind)
    has_value = _swig_new_instance_method(_NvRules.IMetric_has_value)
    as_double = _swig_new_instance_method(_NvRules.IMetric_as_double)
    as_uint64 = _swig_new_instance_method(_NvRules.IMetric_as_uint64)
    as_string = _swig_new_instance_method(_NvRules.IMetric_as_string)
    num_instances = _swig_new_instance_method(_NvRules.IMetric_num_instances)
    has_correlation_ids = _swig_new_instance_method(_NvRules.IMetric_has_correlation_ids)
    correlation_ids = _swig_new_instance_method(_NvRules.IMetric_correlation_ids)

# Register IMetric in _NvRules:
_NvRules.IMetric_swigregister(IMetric)

class ISourceInfo(object):
    r"""Proxy of C++ NV::Rules::ISourceInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_ISourceInfo
    file_name = _swig_new_instance_method(_NvRules.ISourceInfo_file_name)
    line = _swig_new_instance_method(_NvRules.ISourceInfo_line)

# Register ISourceInfo in _NvRules:
_NvRules.ISourceInfo_swigregister(ISourceInfo)

class INvtxRange(object):
    r"""Proxy of C++ NV::Rules::INvtxRange class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    PayloadType_PAYLOAD_UNKNOWN = _NvRules.INvtxRange_PayloadType_PAYLOAD_UNKNOWN
    
    PayloadType_PAYLOAD_UINT64 = _NvRules.INvtxRange_PayloadType_PAYLOAD_UINT64
    
    PayloadType_PAYLOAD_INT64 = _NvRules.INvtxRange_PayloadType_PAYLOAD_INT64
    
    PayloadType_PAYLOAD_DOUBLE = _NvRules.INvtxRange_PayloadType_PAYLOAD_DOUBLE
    
    PayloadType_PAYLOAD_UINT32 = _NvRules.INvtxRange_PayloadType_PAYLOAD_UINT32
    
    PayloadType_PAYLOAD_INT32 = _NvRules.INvtxRange_PayloadType_PAYLOAD_INT32
    
    PayloadType_PAYLOAD_FLOAT = _NvRules.INvtxRange_PayloadType_PAYLOAD_FLOAT
    
    PayloadType_PAYLOAD_JSON = _NvRules.INvtxRange_PayloadType_PAYLOAD_JSON
    
    __swig_destroy__ = _NvRules.delete_INvtxRange
    name = _swig_new_instance_method(_NvRules.INvtxRange_name)
    has_attributes = _swig_new_instance_method(_NvRules.INvtxRange_has_attributes)
    category = _swig_new_instance_method(_NvRules.INvtxRange_category)
    color = _swig_new_instance_method(_NvRules.INvtxRange_color)
    payload_type = _swig_new_instance_method(_NvRules.INvtxRange_payload_type)
    payload_as_uint64 = _swig_new_instance_method(_NvRules.INvtxRange_payload_as_uint64)
    payload_as_double = _swig_new_instance_method(_NvRules.INvtxRange_payload_as_double)
    payload_as_string = _swig_new_instance_method(_NvRules.INvtxRange_payload_as_string)
    message = _swig_new_instance_method(_NvRules.INvtxRange_message)

# Register INvtxRange in _NvRules:
_NvRules.INvtxRange_swigregister(INvtxRange)

class INvtxDomainInfo(object):
    r"""Proxy of C++ NV::Rules::INvtxDomainInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_INvtxDomainInfo
    name = _swig_new_instance_method(_NvRules.INvtxDomainInfo_name)
    push_pop_ranges = _swig_new_instance_method(_NvRules.INvtxDomainInfo_push_pop_ranges)
    push_pop_range = _swig_new_instance_method(_NvRules.INvtxDomainInfo_push_pop_range)
    start_end_ranges = _swig_new_instance_method(_NvRules.INvtxDomainInfo_start_end_ranges)
    start_end_range = _swig_new_instance_method(_NvRules.INvtxDomainInfo_start_end_range)

# Register INvtxDomainInfo in _NvRules:
_NvRules.INvtxDomainInfo_swigregister(INvtxDomainInfo)

class INvtxState(object):
    r"""Proxy of C++ NV::Rules::INvtxState class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_INvtxState
    domains = _swig_new_instance_method(_NvRules.INvtxState_domains)
    domain_by_id = _swig_new_instance_method(_NvRules.INvtxState_domain_by_id)

# Register INvtxState in _NvRules:
_NvRules.INvtxState_swigregister(INvtxState)

class IAction(object):
    r"""Proxy of C++ NV::Rules::IAction class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IAction
    name = _swig_new_instance_method(_NvRules.IAction_name)
    metric_by_name = _swig_new_instance_method(_NvRules.IAction_metric_by_name)
    metric_names = _swig_new_instance_method(_NvRules.IAction_metric_names)
    add_integer_metric = _swig_new_instance_method(_NvRules.IAction_add_integer_metric)
    add_double_metric = _swig_new_instance_method(_NvRules.IAction_add_double_metric)
    add_string_metric = _swig_new_instance_method(_NvRules.IAction_add_string_metric)
    source_info = _swig_new_instance_method(_NvRules.IAction_source_info)
    nvtx_state = _swig_new_instance_method(_NvRules.IAction_nvtx_state)

# Register IAction in _NvRules:
_NvRules.IAction_swigregister(IAction)

class IRange(object):
    r"""Proxy of C++ NV::Rules::IRange class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IRange
    num_actions = _swig_new_instance_method(_NvRules.IRange_num_actions)
    action_by_idx = _swig_new_instance_method(_NvRules.IRange_action_by_idx)
    actions_by_nvtx = _swig_new_instance_method(_NvRules.IRange_actions_by_nvtx)

# Register IRange in _NvRules:
_NvRules.IRange_swigregister(IRange)

class IFrontend(object):
    r"""Proxy of C++ NV::Rules::IFrontend class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    MsgType_MSG_NONE = _NvRules.IFrontend_MsgType_MSG_NONE
    
    MsgType_MSG_OK = _NvRules.IFrontend_MsgType_MSG_OK
    
    MsgType_MSG_WARNING = _NvRules.IFrontend_MsgType_MSG_WARNING
    
    MsgType_MSG_ERROR = _NvRules.IFrontend_MsgType_MSG_ERROR
    
    __swig_destroy__ = _NvRules.delete_IFrontend
    message = _swig_new_instance_method(_NvRules.IFrontend_message)
    load_chart_from_file = _swig_new_instance_method(_NvRules.IFrontend_load_chart_from_file)

# Register IFrontend in _NvRules:
_NvRules.IFrontend_swigregister(IFrontend)

class IBaseContext(object):
    r"""Proxy of C++ NV::Rules::IBaseContext class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IBaseContext
    handle_exception = _swig_new_instance_method(_NvRules.IBaseContext_handle_exception)

# Register IBaseContext in _NvRules:
_NvRules.IBaseContext_swigregister(IBaseContext)

class IController(object):
    r"""Proxy of C++ NV::Rules::IController class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IController
    propose_rule = _swig_new_instance_method(_NvRules.IController_propose_rule)

# Register IController in _NvRules:
_NvRules.IController_swigregister(IController)

class IEvaluator(IBaseContext):
    r"""Proxy of C++ NV::Rules::IEvaluator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IEvaluator
    require_metric = _swig_new_instance_method(_NvRules.IEvaluator_require_metric)
    require_rule = _swig_new_instance_method(_NvRules.IEvaluator_require_rule)

# Register IEvaluator in _NvRules:
_NvRules.IEvaluator_swigregister(IEvaluator)

class IContext(IBaseContext):
    r"""Proxy of C++ NV::Rules::IContext class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IContext
    controller = _swig_new_instance_method(_NvRules.IContext_controller)
    frontend = _swig_new_instance_method(_NvRules.IContext_frontend)
    num_ranges = _swig_new_instance_method(_NvRules.IContext_num_ranges)
    range_by_idx = _swig_new_instance_method(_NvRules.IContext_range_by_idx)

# Register IContext in _NvRules:
_NvRules.IContext_swigregister(IContext)



